\chapter {Universal Function}
\newcommand{\psiex}{\ensuremath{\psi_{\mathcal{U}}^{(k)} (e, \vec{x})}}
\newcommand{\psiuex}{\ensuremath{\psi_e^{(k)} (\vec{x})}}
We'll now see how the theory we described up until now allows us to
prove something a bit surprising. This is to say, the existence of
universal functions/programs, able to reproduce the behaviour of each
and every other computable function/program. Let's consider the function

\[
  \psi(x,y) = \varphi_x(y)
\]

We can already observe that $\psi$ is a ``universal function'', that
captures all unary functions $\varphi_1, \varphi_2, \dots$. In fact,
for all fixed $e \in \nat$
\[
  g(y) = \psi(e,y) = \varphi_e(y) \quad \rightsquigarrow \quad g = \varphi_e
\]
so, thanks to $e$, $\psi$ rapresents all computable functions in the
form $\nattonat$.

\begin{definition}
  The universal function for k-ary functions (with $k \in \nat$) is
  defined as
  \[
    \psi_{\mathcal{U}}^{(k)} : \nat^{k+1} \rightarrow \nat
  \]
  \[
    \psiex = \psiuex
  \]
\end{definition}
$\psi$ functions are this well defined, but are they computable? If
the answer is yes a program $P_{\mathcal{U}}$ computing $\psi$ would
be able to compute all k-ary functions. It includes in itself all
other computable programs, and we can call it a Universal Computer
\cite{davis:2011}.

At first glance this might seem odd, but tinking again it recives in
input:
\begin{itemize}
\item $e$ (the index of the program, a \textit{description} of the
  program $P_e$ to run)
\item $\vec{x}$ the arguments
\end{itemize}
We observe that it fits the description of an interpreter.

In fact, the following result applies

\begin{theorem}
  $\forall k \geq 1$ the universal function $\psi_{\mathcal{U}}^{(k)}$
  is computable.

  \begin{proof}
    Informally, we can say that if we fix $k \geq 1$ and an index
    $e \in \nat$ and the arguments $\vec{x} \in \nat^k$ we can compute
    $\psiex = \psiuex$ as follows:
    \begin{itemize}
    \item we build the program $P_e = \gamma^{-1}(e)$;
    \item we simulate $P_e$ on input $\vec{x}$
    \item if $P_e(\vec{x})\downarrow$, the value of $\psiex$ is in
      $R_1$, otherwise it is ok.
    \end{itemize}
    This way everything is effective, and for the Church-Turing
    thesis computable.

    But we want to be more formal than this. More precisely we'll need
    some programs in order to accomplish this:

    \paragraph{Configuration of registers}
    Given the registers of the machine $(r_1, r_2, \dots, r_n)$
    \[
      \begin{tabu}{|c|c|c|c|c}
        \hline
        r_1 & r_2 & r_3 & 0 & \dots \\ \hline
      \end{tabu}
    \]
    the \textit{configuration of registers} is given by
    \[ c = \prod_{i \geq 1} p_i^{r_i} \]
    This way the value of the registers $\forall i \quad r_i = (c)_i$

    \paragraph{The state of the machine}
    The state of the machine is encoded with \[ \sigma = \Pi(j, c) \]
    where $j$ is the next instruction to execute and $c$ is the
    configuration of registers.

    We want to show that the functions

    \[
      c_k : \nat^{k+2} \rightarrow \nat
    \]

    \[
      c_k(e, \vec{x}, t) = \begin{cases}
        % Insert the function definition we saw in class
        x & 0 \\
        y & 1
      \end{cases}
    \]

    \[
      j_k : \nat^{k+2} \rightarrow \nat
    \]

    \[
      j_k(e, \vec{x}, t) = \begin{cases}
        % Insert the function definition we saw in class
        x & 0 \\
        y & 1
      \end{cases}
    \]

    At this point we have that
    \[\psiex = \psiuex = (c_k(e,\vec{x}, \mu t \; . \; j_k(e, \vec{x}, t)))_1\]
    so if we prove that $c_k, j_k$ are computable we can conclude that
    also $\psi_{\mathcal{U}}^{(k)}$ si computable.  We proceed in the
    same manner way we did in the proof \S\ref{reqc}, by proving that
    $c_k, j_k \in \pr$ (in fact, this can be seen as a more formal
    prove of the same fact, the only difference is that in the latter
    demonstration we defined $c_p, j_p$ with \emph{a fixed $P$}, here
    instead $P$ is a parameter). 

    Explictly, each step:

    \newcommand{\uarg}{{\mbox{arg}}}
    \newcommand{\uargh}{{\mbox{arg}_h}}
    \begin{enumerate}[label=(\alph*)]
    \item arguments of an URM instruction $( i = \beta(\mbox{Instruction}))$

      $Z_\uarg (i) = qt(4, i) + 1$
              
      $S_\uarg (i) = qt(4,i) + 1$
              
      $T_\uargh(i) = \Pi_h(qt(4,i)) + 1 \quad h \in \{1,2\}$
              
      $J_\uargh(i) = \nu_h(qt(4,i)) + 1 \quad h \in \{1,2,3\}$
      
    \item effect of executing an instruction on the configuration $C$

      \[
        \begin{tabu}{l l}
          \mbox{zero}(c,n) = qt(p_n^{(c)_n}, c) & Z(n) \\
          \mbox{succ}(c,n) = p_n \cdot c & S(n) \\
          \mbox{tfr}(c,m,n) = qt(p_n^{(c)_n}, x) \cdot p_n^{(c)_m} & T(m,n)
        \end{tabu}
      \]

    \item effect on the configuration of registers of the execution of
      the instruction $i=\beta(\mbox{Instruction})$

      \newcommand{\change}{\mbox{change}}
      \[
        \change(c,i) = \begin{cases}
          \mbox{zero}(c, Z_\uarg(i)) & rm(4,i) = 0 \\
          \mbox{succ}(c, S_\uarg(i)) & rm(4,i) = 1 \\
          \mbox{tfr}(c, T_{\uarg_1}(i), T_{\uarg_2}(i)) & rm(4,i) = 2 \\
          c & rm(4,i) = 3
      \end{cases} 
    \]

  \item configuration of the registers if the current one ($c$) and
    the $t$ instruction of $P_e$ is executed

    \newcommand{\nextconf}{\mbox{nextconf}}
    \[
      \nextconf(e,c,t) = \begin{cases}
        \change(c, a(e,t)) & 1 \leq t \leq \ell(e) \\
        c & \mbox{otherwise}
      \end{cases}
    \]

  \item next configuration of registersif the $t^{\mbox{th}}$
    instruction $i=\beta(\mbox{Instruction})$ is executed

    \newcommand{\instr}{\mbox{instr}}
    \[
      \instr(c, i, t) = \begin{cases}

        t+1 & (rm(4,1) \neq 3) \vee (rm(4,i) = 3 \wedge (c)_{J_{\uarg_1(c)}} \neq (c)_{J_{\uarg_2(i)}}) \\
        J_{\uarg_3(c)} & \mbox{otherwise}
      \end{cases}
    \]

  \item number of the next instruction if the $t^{\mbox{th}}$
    instruction of $P_e$ is execeuted on the configuration $c$

    \newcommand{\nextinstr}{\mbox{nextinstr}}
    \[
      \nextinstr(e,c,t) = \begin{cases}
        \instr(c, a(e,t), t) & 1 \leq t \leq \ell(e) \wedge \instr(c, a(e,t), t) \leq \ell(e) \\
        0 & \mbox{otherwise}
      \end{cases}
    \]
  \end{enumerate}

  At this point we can define $c_k$ and $j_k$

  $c_k(e, \vec{x}, 0) = \prod_{i=1}^kp_i^{x_i}$

  $j_k(e, \vec{x}, 0) = 1$

  $c_k(e, \vec{x}, t+1) = \mbox{nextconf} (e, c_k(e, \vec{x}, t), j_k(e,\vec{x},t))$

  $j_k(e, \vec{x}, t+1) = \mbox{nextinstr} (e, c_k(e, \vec{x}, t), j_k(e,\vec{x},t))$

  Therefore

  \[
    \sigma_k(e,\vec{x},t) = \Pi(j_k(e,\vec{x},t), c_k(e,\vec{x},t))
  \]

  can be defined with primitive recursion, therefore $\sigma \in \pr \Rightarrow c_k, j_j \in \pr$

  \[
    \psiex = c_k(e, \vec{x}, \mu t \; . \; j_k(e,\vec{x},t)) \quad \in \mathcal{R} = \mathcal{C}
  \]
  \end{proof}
\end{theorem}

As a corollary, we obtain the decidability of two statements that will
be really useful in the next chapters.

\begin{corollary}
  The following predicates are decidable:
  \begin{enumerate}[label=(\alph*)]
  \item $H_k(e, \vec{x}, t) \equiv$ ``$P_e(\vec{x})\downarrow$ in $t$
    or less steps''
  \item $S_k(e, \vec{x}, y, t) \equiv$ ``$P_e(\vec{x})\downarrow y$ in
    $t$ or less steps''
  \end{enumerate}
  \begin{proof}
    \begin{enumerate}[label=(\alph*)]
    \item We observe that
      $H_k(e, \vec{x}, t) \equiv (j_k(e,\vec{x}, t) = 0)$ and therefore
      we have
      
      $\chi_{H_k}(e, \vec{x}, t) = \overline{sg}(j_k(e,\vec{x},t))$
    \item We observe that
      $S_k(e, \vec{x}, y, t) \equiv ((j_k(e,\vec{x},t) = 0) \wedge ((c_k(e,\vec{x},t))_1)=y)$
    \end{enumerate}
  \end{proof}
\end{corollary}

Also, from the theorem we deduce the possibility to express every
computbale function in the so said Kleene normal form (KNF)

\begin{corollary}[Kleene Normal Form]
  $\forall e,k \in \nat \quad \forall x \in \nat^k$
  \[
    \psiuex = (\mu z \;.\; |\chi_{S_k}(e, \vec{x}, (z)_1, (z)_2) - 1|)_1
  \]
\end{corollary}

\textbf{Observations:}
\begin{enumerate}[label=\roman*.]
\item This corollary highlights how each computable function (or
  equivlently $\in\pr$) can be obtained from primitive recursion
  functions using minimalization maximum one time (we can use just one
  \texttt{while})
\item Minimalization allows us to ``search'' a single value that has a
  certain property. The one we used is a technique to search couples
  of values generalizable to tuples.
\end{enumerate}

\section{Applications of the universal function}
Reminding that we already observed that if $f : \nattonat$ is a total
computable injective function, then
\[
  f^{-1}(x) = \begin{cases}
    y & \quad \mbox{if exists $y$ s.t. } f(y) = x \\
    \uparrow & \quad \mbox{otherwise}
\end{cases}
\]
is computable since $f^{-1} = \mu y \; . \; |f(y) = x|$. We can verify
that the hypotesis of \emph{totalyty} can be omitted.

\begin{theorem}
  Let $f: \nattonat$ computable and injective. Then
  $f^{-1}: \nattonat$ is computable.
  \begin{proof}
    Since $f$ is computable, exists $e \in \nat$ s.t. $\varphi_e =
    f$. Now is sufficent to observe that
    \[
      \begin{split}
        f^{-1}(x) &= (\mu z \; . \;  "S(e, (z)_1, x, (z)_2)")_1 \\
        &= (\mu z \; . \; |\chi_S(e, (z)_1, x, (z)_2) - 1|)_1
      \end{split}
    \]
  \end{proof}
\end{theorem}

We can now find new uncomputable functions and undecidable predicates:

\begin{theorem}
  The statement ``$\varphi_x$ is total'' is undecidable
  \begin{proof}
    Let $Tot(x)$ be the predicate
    \[ Tot(x) \equiv \mbox{ ``$\varphi_x$ is total''} \] and assume
    that it si decidable. Then the charateristic function
    \[
      \chi_{Tot}(x) = \begin{cases}
        1 & \varphi_x \mbox{ is total} \\
        0 & \mbox{otherwise}
      \end{cases}
    \]
    is computable. If this is the case, then the function
    \[
      g(x) = \begin{cases}
        \varphi_x (x) + 1 & \varphi_x \mbox{ total}\\
        1 & \mbox{otherwise}
      \end{cases}
    \]
    is both total and computable, since by hypotesis ``$\varphi_x$
    total'' is decidable and $\varphi_x(x) + 1 = \psi(x,x) + 1$ is
    computable. But by looking at the definition by cases that it is
    false. It required the used functions to be total:
    \[ g(x) \neq (\psi(x,x) + 1) \cdot \chi_{Tot}(x) + 0 \cdot (1
      \dotdiv \chi_{Tot}(x))\] wich is undefined if
    $\psi(x,x) \uparrow$. The theorem of definition by cases continues
    to be valid for non total functions, but the proof must be
    changed. More in detail:
    \[
      \begin{split}
        g(x) &= (\mu z \;.\; \mbox{``}S(x,x,(z)_1, (z)_2) \wedge \lnot Tot(x)\mbox{''})_1 + 1 \\
        &= (\mu z \;.\; | \chi_{S(x,x,(z)_1, (z)_2) \wedge \lnot Tot(x)} -  1|)_1 + 1 \\
      \end{split}
    \]
    and $\forall x$ if $\varphi_x$ total
    $\Rightarrow g(x) = \varphi_x(x) + 1 \Rightarrow \varphi_x \neq
    g$. That is to say that $g$ is total and computa but different
    from every other total computable function, wich is
    absurd. Therefore $Tot(x)$ is not computable.
  \end{proof}
\end{theorem}

\textbf{Observation:} The ame applies to prove that the following
statements are undecidable (Halting problem):
\begin{itemize}
\item
  $P_1(x) \equiv \mbox{``}x \ in W_x\mbox{''} \equiv
  \mbox{``}\varphi_x(x) \downarrow \mbox{''}$
\item
  $P_2(x,y) \equiv \mbox{``} y \in W_x \mbox{''} \equiv
  \mbox{``}\varphi_x(y) \downarrow\mbox{''}$
\end{itemize}

\section{Effective operations on computable functions}
The existence of the universal function, together with the \smn
theorem allows us to prove formally the effectivity of various
operations on indices of computable functions (in other words,
programs).
% Program that takes input $ e $ and $ \vec{x} $ and returns
% $ \phi_e(\vec{x}) \forall e$ so I find all the computable functions.

% More specifically, the function $ \psi_u(x,y) = \phi_x(y)$,
% $ \psi : \nat^2 \rightarrow \nat $

% In other words, the interpreter exists.

% \textbf{Theorem}: This is computable.
% $ \forall k \geq 1 \quad \psi_u^{(k)} $ is computable.

% Let's prove it. Suppose we have a fixed $ k \geq 1 $.

% How do I calculate
% $ e \in \nat, \vec{x} \in \nat^k, \psi_u^{k}(e, \vec{x}) $?

% Fact $e$, calculation $ \gamma^{-1}(e) = P_e $

% But we don't want to decode the program.
