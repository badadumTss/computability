\chapter{Enumeration of programs}

Review: $ A, B $ sets, $ |A| = |B| $ if $ \exists f:A\rightarrow B $ biunivocal. Furthermore $ |A| \leq |B| $ if $ \exists f:A\rightarrow B $ injective or there exists $g$ opposite direction surjective.

$A$ is countable if $ |A| \leq |\nat| $, that is, $ \exists g: \nat \rightarrow A $ surjective.

An enumeration is without repetitions if in addition to being surjective it is also injective. Let's say that an enumeration is effective when it is computable or made from pieces that are computable (e.g. ennuple of results).

\textbf{Observation:} $ \nat^2 $, $ \nat^3 $ and $ \bigcup_{k\geq 1} \nat^k $ can be numbered effectively.

In particular the couples in $ \nat^2 $ can be encoded as $ \pi(x,y) = 2^x(2y+1)-1 $ which is computable. The inverse is $ \pi^{-1}(n) = (\pi_1(n), \pi_2(n)) $

The triple instead is a pair of a pair and an element. $ \upsilon (x,y,z) = \pi (x, \pi(y,z))$. The inverse is also obtained from the inverse of the first.

For lists we need an encoding $ \tau . \bigcup_{K \geq 1} \nat^k \rightarrow \nat $ we exploit the uniqueness of the prime numbers: $ \tau(a_1,\dots,a_k) = \Pi_{i=1}^k p_i^{a_i}$ where $ p_i $ is the $i$-th prime number.\\This, however, leads us to lose any zeros, since the encodings for (1,1) and (1,1,0) would be the same because the exponential function in 0 = 1.

So we use something that works: $ (\Pi_{i=1}^{k-1} p_i^{a_i}) \times p_k^{a_k+1} - 2$. For decoding we can proceed as usual, but limited minimization can be used.\\ Hint: $ max \{z \leq x . P(z)\} x - min\{\delta \leq x . P(x-\delta)\}$

But I don't just want the length, I also need the list of items. I need a function: \begin{equation*}
  a(x,i) = \begin{cases}
    (x+2)_i   & 1 \leq i \leq k-1 \\
    (x+2)_k-1 & i = k
  \end{cases}
\end{equation*}
And this is the inverse function of $\tau$. And these functions are computable recursive primitives.

To compute instructions: Let us take $ \mathcal{F} $ set of URM instructions, $ \mathcal{P} $ URM programs. Let's take function $ \beta:\mathcal{F}\rightarrow\nat $
\begin{itemize}
\item $ \beta(z(n)) = 4 \times (n-1) $;
\item $ \beta(s(n)) = 4 \times (n-1)+1 $;
\item $ \beta(t(m,n)) = 4 \times \pi(m-1,n-1)+2 $;
\item $ \beta(j(m,n,t)) = 4 \times \upsilon(m-1,n-1,t-1)+3 $;
\end{itemize}

The decoding of this monstrosity is obtained from the previous inverse functions applied on the basis of the dimension and the rest of the number.

\textbf{Example:} P = T (1,2); S (2); T (2,1) = $ \tau(10,5,6) = 2^{10} 3^5 5^{6+1} -2 $

The two-way function between programs and numbers has been demonstrated.

\begin{notation} given an effective enumeration (in our case the one defined previously) we say that $ \gamma(P) $ is the code of P (also called G\"{o} of the number), if $ \gamma(P) = n $ then $P$ is the $n$-th program.
\end{notation}

\begin{notation} $ \Phi_n^{(k)}: \nat^k\rightarrow\nat $ function of $K$ arguments computed by program $n$, that is, by program $ \gamma^{-1}(n) $, if $k = 1$ is is omitted. The function domain  is $ W_n^{k} = dom(\Phi_k^{(k)}) = \{\vec{x} | \Phi_k^{(k)})(\vec{x})\downarrow  \} \subseteq \nat^k$

  The function codomain: $ E^{(k)}_n = \Phi_k^{(k)}) = \{\vec{x} | \vec{x} \in W_n^{(k)} \} \subseteq \nat^k$
\end{notation}

So for example the program $ \Phi_{19439999998} = x+1 $, $ W_{19439999998} = \nat $, $ E_{19439999998} = \nat \setminus \{0\} $

Now we have an enumeration of all the unary computable functions that is \{$ \Phi_n $ . $ n \in \nat $ \} each function with infinite repetitions.

Remember we have indicated the computable functions of $k$ arguments as $ \mathcal{C} ^ {(k)} $, where $ | \mathcal{C} ^ {(k)} | \leq (=) | \nat | $ and therefore being $ \mathcal{C} = \bigcup_{K \geq 1} \mathcal{C} ^ {(k)} $ a union of countable sets it is still countable.
